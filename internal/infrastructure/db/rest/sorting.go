// Code generated by ent, DO NOT EDIT.

package rest

import (
	"fmt"
	"slices"
	"strings"

	"entgo.io/ent/dialect/sql"
	ent "github.com/alfariiizi/vandor/internal/infrastructure/db"
	"github.com/alfariiizi/vandor/internal/infrastructure/db/notification"
	"github.com/alfariiizi/vandor/internal/infrastructure/db/product"
	"github.com/alfariiizi/vandor/internal/infrastructure/db/session"
	"github.com/alfariiizi/vandor/internal/infrastructure/db/user"
)

type Sorted struct {
	// Field is the field to sort by. Can be a standard field name (e.g. "name"), or a custom field
	// name (e.g. "pets.age.sum"). If no field is provided, the default field will be used.
	Field *string `json:"sort" form:"sort,omitempty"`

	// Order is the order to sort by. Can be either "asc" or "desc". If no order is provided, the
	// default order will be used.
	Order *orderDirection `json:"order" form:"order,omitempty"`
}

// Validate validates the sorting fields and applies any necessary defaults.
func (s *Sorted) Validate(cfg *SortConfig) error {
	if s.Field == nil {
		if cfg.DefaultField == "" {
			return nil
		}
		s.Field = &cfg.DefaultField
	}
	if s.Order == nil {
		s.Order = &cfg.DefaultOrder
	}

	if !slices.Contains(cfg.Fields, *s.Field) {
		return &ErrBadRequest{Err: fmt.Errorf("invalid sort field: %s", *s.Field)}
	}

	if !slices.Contains(OrderDirections, *s.Order) {
		return &ErrBadRequest{Err: fmt.Errorf("invalid order: %s", *s.Order)}
	}

	return nil
}

// withOrderTerm returns the OrderTermOption (asc/desc) based on the provided order string.
func withOrderTerm(order orderDirection) sql.OrderTermOption {
	if order == orderAsc {
		return sql.OrderAsc()
	}
	return sql.OrderDesc()
}

func withFieldSelector(field string, order orderDirection) func(*sql.Selector) {
	if order == orderAsc {
		return ent.Asc(field)
	}
	return ent.Desc(field)
}

type SortConfig struct {
	Fields       []string
	DefaultField string
	DefaultOrder orderDirection
}

type orderDirection string

var (
	orderAsc  orderDirection = "asc"
	orderDesc orderDirection = "desc"

	// OrderDirections are the allowed order directions that can be provided.
	OrderDirections = []orderDirection{orderAsc, orderDesc}
	// NotificationSortConfig defines the default sort configuration for Notification.
	NotificationSortConfig = &SortConfig{
		Fields: []string{
			"id",
			"random",
			"user.email",
		},
		DefaultField: "id",
		DefaultOrder: "asc",
	}
	// ProductSortConfig defines the default sort configuration for Product.
	ProductSortConfig = &SortConfig{
		Fields: []string{
			"id",
			"random",
			"user.email",
		},
		DefaultField: "id",
		DefaultOrder: "asc",
	}
	// SessionSortConfig defines the default sort configuration for Session.
	SessionSortConfig = &SortConfig{
		Fields: []string{
			"id",
			"random",
			"user.email",
		},
		DefaultField: "id",
		DefaultOrder: "asc",
	}
	// UserSortConfig defines the default sort configuration for User.
	UserSortConfig = &SortConfig{
		Fields: []string{
			"email",
			"id",
			"notifications.count",
			"products.count",
			"random",
			"sessions.count",
		},
		DefaultField: "id",
		DefaultOrder: "asc",
	}
)

// isSpecializedSort checks if the sort field is a specialized sort field.
func isSpecializedSort(parts []string) (isCount, isSum bool) {
	switch {
	case len(parts) == 3:
		switch parts[2] {
		case "count":
			isCount = true
		case "sum":
			isSum = true
		}
	case len(parts) == 2:
		switch parts[1] {
		case "count":
			isCount = true
		case "sum":
			isSum = true
		}
	}
	return isCount, isSum
}

// applySortingNotification applies sorting to the query based on the provided sort and
// order fields. Note that all inputs provided MUST ALREADY BE VALIDATED.
func applySortingNotification(query *ent.NotificationQuery, field string, order orderDirection) *ent.NotificationQuery {
	if parts := strings.Split(field, "."); len(parts) > 1 {
		dir := withOrderTerm(order)

		switch parts[0] {
		case notification.EdgeUser:
			return query.Order(notification.ByUserField(parts[1], dir))
		}
	}
	if field == "random" {
		return query.Order(sql.OrderByRand())
	}
	return query.Order(withFieldSelector(field, order))
}

// applySortingProduct applies sorting to the query based on the provided sort and
// order fields. Note that all inputs provided MUST ALREADY BE VALIDATED.
func applySortingProduct(query *ent.ProductQuery, field string, order orderDirection) *ent.ProductQuery {
	if parts := strings.Split(field, "."); len(parts) > 1 {
		dir := withOrderTerm(order)

		switch parts[0] {
		case product.EdgeUser:
			return query.Order(product.ByUserField(parts[1], dir))
		}
	}
	if field == "random" {
		return query.Order(sql.OrderByRand())
	}
	return query.Order(withFieldSelector(field, order))
}

// applySortingSession applies sorting to the query based on the provided sort and
// order fields. Note that all inputs provided MUST ALREADY BE VALIDATED.
func applySortingSession(query *ent.SessionQuery, field string, order orderDirection) *ent.SessionQuery {
	if parts := strings.Split(field, "."); len(parts) > 1 {
		dir := withOrderTerm(order)

		switch parts[0] {
		case session.EdgeUser:
			return query.Order(session.ByUserField(parts[1], dir))
		}
	}
	if field == "random" {
		return query.Order(sql.OrderByRand())
	}
	return query.Order(withFieldSelector(field, order))
}

// applySortingUser applies sorting to the query based on the provided sort and
// order fields. Note that all inputs provided MUST ALREADY BE VALIDATED.
func applySortingUser(query *ent.UserQuery, field string, order orderDirection) *ent.UserQuery {
	if parts := strings.Split(field, "."); len(parts) > 1 {
		dir := withOrderTerm(order)

		isCount, isSum := isSpecializedSort(parts)

		switch parts[0] {
		case user.EdgeProducts:
			switch {
			case isCount:
				return query.Order(user.ByProductsCount(dir))
			case isSum:
				return query.Order(user.ByProducts(sql.OrderBySum(parts[1], dir)))
			default:
				return query.Order(user.ByProducts(sql.OrderByField(parts[1], dir)))
			}
		case user.EdgeSessions:
			switch {
			case isCount:
				return query.Order(user.BySessionsCount(dir))
			case isSum:
				return query.Order(user.BySessions(sql.OrderBySum(parts[1], dir)))
			default:
				return query.Order(user.BySessions(sql.OrderByField(parts[1], dir)))
			}
		case user.EdgeNotifications:
			switch {
			case isCount:
				return query.Order(user.ByNotificationsCount(dir))
			case isSum:
				return query.Order(user.ByNotifications(sql.OrderBySum(parts[1], dir)))
			default:
				return query.Order(user.ByNotifications(sql.OrderByField(parts[1], dir)))
			}
		}
	}
	if field == "random" {
		return query.Order(sql.OrderByRand())
	}
	return query.Order(withFieldSelector(field, order))
}
