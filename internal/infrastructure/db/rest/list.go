// Code generated by ent, DO NOT EDIT.

package rest

import (
	"context"
	"fmt"
	"math"
	"slices"

	"entgo.io/ent/dialect/sql"
	ent "github.com/alfariiizi/vandor/internal/infrastructure/db"
	"github.com/alfariiizi/vandor/internal/infrastructure/db/predicate"
	"github.com/alfariiizi/vandor/internal/infrastructure/db/user"
)

type PageConfig struct {
	MinItemsPerPage int `json:"min_items_per_page"`
	ItemsPerPage    int `json:"items_per_page"`
	MaxItemsPerPage int `json:"max_items_per_page"`
}

var (
	firstPage = 1
	// DefaultPageConfig defines the page configuration for LIST-related endpoints
	// for all entities by default. If the configuration is not overridden for a
	// specific entity, this will be used.
	DefaultPageConfig = &PageConfig{
		MinItemsPerPage: 1,
		ItemsPerPage:    10,
		MaxItemsPerPage: 100,
	}
	// NotificationPageConfig defines the page configuration for LIST-related endpoints
	// for Notification.
	NotificationPageConfig = &PageConfig{
		MinItemsPerPage: DefaultPageConfig.MinItemsPerPage,
		ItemsPerPage:    DefaultPageConfig.ItemsPerPage,
		MaxItemsPerPage: DefaultPageConfig.MaxItemsPerPage,
	}
	// ProductPageConfig defines the page configuration for LIST-related endpoints
	// for Product.
	ProductPageConfig = &PageConfig{
		MinItemsPerPage: DefaultPageConfig.MinItemsPerPage,
		ItemsPerPage:    DefaultPageConfig.ItemsPerPage,
		MaxItemsPerPage: DefaultPageConfig.MaxItemsPerPage,
	}
	// SessionPageConfig defines the page configuration for LIST-related endpoints
	// for Session.
	SessionPageConfig = &PageConfig{
		MinItemsPerPage: DefaultPageConfig.MinItemsPerPage,
		ItemsPerPage:    DefaultPageConfig.ItemsPerPage,
		MaxItemsPerPage: DefaultPageConfig.MaxItemsPerPage,
	}
	// UserPageConfig defines the page configuration for LIST-related endpoints
	// for User.
	UserPageConfig = &PageConfig{
		MinItemsPerPage: DefaultPageConfig.MinItemsPerPage,
		ItemsPerPage:    DefaultPageConfig.ItemsPerPage,
		MaxItemsPerPage: DefaultPageConfig.MaxItemsPerPage,
	}
)

// PagableQuery is an interface for ent queries which support providing limit/offset.
type PagableQuery[P any, T any] interface {
	Limit(int) P
	Offset(int) P
	Count(ctx context.Context) (int, error)
	All(ctx context.Context) ([]*T, error)
}

// PagedResponse is the JSON response structure for paged queries.
type PagedResponse[T any] struct {
	Page       int  `json:"page"`         // Current page number.
	TotalCount int  `json:"total_count"`  // Total number of items.
	LastPage   int  `json:"last_page"`    // Last page number.
	IsLastPage bool `json:"is_last_page"` // Whether this is the last page.
	Content    []*T `json:"content"`      // Paged data.
}

// GetPage returns the current page number.
func (p *PagedResponse[T]) GetPage() int {
	return p.Page
}

// GetTotalCount returns the total number of items.
func (p *PagedResponse[T]) GetTotalCount() int {
	return p.TotalCount
}

// GetLastPage returns the last page number.
func (p *PagedResponse[T]) GetLastPage() int {
	return p.LastPage
}

// GetIsLastPage returns whether this is the last page.
func (p *PagedResponse[T]) GetIsLastPage() bool {
	return p.IsLastPage
}

type Paginated[P PagableQuery[P, T], T any] struct {
	Page         *int `json:"page"     form:"page,omitempty"`
	ItemsPerPage *int `json:"per_page" form:"per_page,omitempty"`
	ResultCount  int  `json:"-"        form:"-"` // ResultCount is populated by the query execution inside of ApplyPagination.
	LastPage     int  `json:"-"        form:"-"` // LastPage is populated by the query execution inside of ApplyPagination.

	hasApplied bool `json:"-" form:"-"`
}

// ApplyPagination applies offsets and limits, and also runs a count query on the
// provided query to calculate total results and what the last page number is.
func (p *Paginated[P, T]) ApplyPagination(ctx context.Context, query P, pageConfig *PageConfig) (P, error) {
	if pageConfig == nil {
		pageConfig = DefaultPageConfig
	}

	if p.Page == nil {
		p.Page = &firstPage
	}

	if p.ItemsPerPage == nil {
		p.ItemsPerPage = &pageConfig.ItemsPerPage
	}

	if *p.ItemsPerPage < pageConfig.MinItemsPerPage {
		return query, &ErrBadRequest{Err: fmt.Errorf("per_page %d is out of bounds, must be >= %d", *p.ItemsPerPage, pageConfig.MinItemsPerPage)}
	}

	if *p.ItemsPerPage > pageConfig.MaxItemsPerPage {
		return query, &ErrBadRequest{Err: fmt.Errorf("per_page %d is out of bounds, must be <= %d", *p.ItemsPerPage, pageConfig.MaxItemsPerPage)}
	}

	if *p.Page < 1 {
		return query, &ErrBadRequest{Err: fmt.Errorf("page %d is out of bounds, must be >= 1", *p.Page)}
	}

	var err error

	p.ResultCount, err = query.Count(ctx)
	if err != nil {
		return query, err
	}

	// TODO: how to calculate this without knowing the total count?
	p.LastPage = int(math.Ceil(float64(p.ResultCount) / float64(*p.ItemsPerPage)))

	if p.LastPage < 1 {
		p.LastPage = 1
	}

	if *p.Page > p.LastPage {
		return query, &ErrBadRequest{Err: fmt.Errorf("page %d is out of bounds, last page is %d", *p.Page, p.LastPage)}
	}

	p.hasApplied = true
	return query.Limit(*p.ItemsPerPage).Offset((*p.Page - 1) * *p.ItemsPerPage), nil
}

// ExecutePaginated executes the query and returns a paged response. If ApplyPagination
// was not called before, it will be called here.
func (p *Paginated[P, T]) ExecutePaginated(ctx context.Context, query P, pageConfig *PageConfig) (*PagedResponse[T], error) {
	if !p.hasApplied {
		var err error
		query, err = p.ApplyPagination(ctx, query, pageConfig)
		if err != nil {
			return nil, err
		}
	}

	data, err := query.All(ctx)
	if err != nil {
		return nil, err
	}

	return &PagedResponse[T]{
		Page:       *p.Page,
		TotalCount: p.ResultCount,
		LastPage:   p.LastPage,
		IsLastPage: *p.Page == p.LastPage,
		Content:    data,
	}, nil
}

// FilterOperation represents if all or any (one or more) filters should be applied.
type FilterOperation string

const (
	FilterOperationAnd FilterOperation = "and" // Represents the "and" predicate, applying against all filters combined.
	FilterOperationOr  FilterOperation = "or"  // Represents the "or" predicate, applying against any number of filters.
)

var (
	// FilterOperations defines the available filter methods.
	FilterOperations = []FilterOperation{FilterOperationAnd, FilterOperationOr}
)

type Filtered[P ~func(*sql.Selector)] struct {
	// FilterOperation controls how multiple predicates are applied together.
	FilterOperation *FilterOperation `json:"filter_op,omitempty" form:"filter_op,omitempty"`
}

// ApplyFilterOperation applies the requested filter operation (if provided) to the
// provided predicates. If no filter operation is provided, the predicates are
// returned with AND.
func (f *Filtered[P]) ApplyFilterOperation(predicates ...P) (P, error) {
	if f.FilterOperation == nil || *f.FilterOperation == FilterOperationAnd {
		return sql.AndPredicates(predicates...), nil
	}
	if !slices.Contains(FilterOperations, *f.FilterOperation) {
		return nil, &ErrBadRequest{Err: fmt.Errorf("invalid filter method: %s", *f.FilterOperation)}
	}
	return sql.OrPredicates(predicates...), nil
}

// ListNotificationParams defines parameters for listing Notifications via a GET request.
type ListNotificationParams struct {
	Sorted
	Paginated[*ent.NotificationQuery, ent.Notification]
}

// ApplySorting applies sorting to the query based on the provided sort and order fields.
func (l *ListNotificationParams) ApplySorting(query *ent.NotificationQuery) error {
	if err := l.Sorted.Validate(NotificationSortConfig); err != nil {
		return err
	}
	if l.Field == nil { // No custom sort field provided and no defaults, so don't do anything.
		return nil
	}
	applySortingNotification(query, *l.Field, *l.Order)
	return nil
}

// Exec wraps all logic (filtering, sorting, pagination, eager loading) and
// executes all necessary queries, returning the results.
func (l *ListNotificationParams) Exec(ctx context.Context, query *ent.NotificationQuery) (results *PagedResponse[ent.Notification], err error) {
	err = l.ApplySorting(EagerLoadNotification(query))
	if err != nil {
		return nil, err
	}
	return l.ExecutePaginated(ctx, query, NotificationPageConfig)
}

// ListProductParams defines parameters for listing Products via a GET request.
type ListProductParams struct {
	Sorted
	Paginated[*ent.ProductQuery, ent.Product]
}

// ApplySorting applies sorting to the query based on the provided sort and order fields.
func (l *ListProductParams) ApplySorting(query *ent.ProductQuery) error {
	if err := l.Sorted.Validate(ProductSortConfig); err != nil {
		return err
	}
	if l.Field == nil { // No custom sort field provided and no defaults, so don't do anything.
		return nil
	}
	applySortingProduct(query, *l.Field, *l.Order)
	return nil
}

// Exec wraps all logic (filtering, sorting, pagination, eager loading) and
// executes all necessary queries, returning the results.
func (l *ListProductParams) Exec(ctx context.Context, query *ent.ProductQuery) (results *PagedResponse[ent.Product], err error) {
	err = l.ApplySorting(EagerLoadProduct(query))
	if err != nil {
		return nil, err
	}
	return l.ExecutePaginated(ctx, query, ProductPageConfig)
}

// ListSessionParams defines parameters for listing Sessions via a GET request.
type ListSessionParams struct {
	Sorted
	Paginated[*ent.SessionQuery, ent.Session]
}

// ApplySorting applies sorting to the query based on the provided sort and order fields.
func (l *ListSessionParams) ApplySorting(query *ent.SessionQuery) error {
	if err := l.Sorted.Validate(SessionSortConfig); err != nil {
		return err
	}
	if l.Field == nil { // No custom sort field provided and no defaults, so don't do anything.
		return nil
	}
	applySortingSession(query, *l.Field, *l.Order)
	return nil
}

// Exec wraps all logic (filtering, sorting, pagination, eager loading) and
// executes all necessary queries, returning the results.
func (l *ListSessionParams) Exec(ctx context.Context, query *ent.SessionQuery) (results *PagedResponse[ent.Session], err error) {
	err = l.ApplySorting(EagerLoadSession(query))
	if err != nil {
		return nil, err
	}
	return l.ExecutePaginated(ctx, query, SessionPageConfig)
}

// ListUserParams defines parameters for listing Users via a GET request.
type ListUserParams struct {
	Sorted
	Paginated[*ent.UserQuery, ent.User]
	Filtered[predicate.User]

	// Filters field "email" to be equal to the provided value.
	UserEmailEQ *string `form:"email.eq,omitempty" json:"user_email_eq,omitempty"`
	// Filters field "email" to be not equal to the provided value.
	UserEmailNEQ *string `form:"email.neq,omitempty" json:"user_email_neq,omitempty"`
	// Filters field "email" to be within the provided values.
	UserEmailIn []string `form:"email.in,omitempty" json:"user_email_in,omitempty"`
	// Filters field "email" to be not within the provided values.
	UserEmailNotIn []string `form:"email.notIn,omitempty" json:"user_email_not_in,omitempty"`
	// Filters field "email" to be equal to the provided value, case-insensitive.
	UserEmailEqualFold *string `form:"email.ieq,omitempty" json:"user_email_equal_fold,omitempty"`
	// Filters field "email" to contain the provided value.
	UserEmailContains *string `form:"email.has,omitempty" json:"user_email_contains,omitempty"`
	// Filters field "email" to contain the provided value, case-insensitive.
	UserEmailContainsFold *string `form:"email.ihas,omitempty" json:"user_email_contains_fold,omitempty"`
	// Filters field "email" to start with the provided value.
	UserEmailHasPrefix *string `form:"email.prefix,omitempty" json:"user_email_has_prefix,omitempty"`
	// Filters field "email" to end with the provided value.
	UserEmailHasSuffix *string `form:"email.suffix,omitempty" json:"user_email_has_suffix,omitempty"`
}

// FilterPredicates returns the predicates for filter-related parameters in User.
func (l *ListUserParams) FilterPredicates() (predicate.User, error) {
	var predicates []predicate.User

	if l.UserEmailEQ != nil {
		predicates = append(predicates, user.EmailEQ(*l.UserEmailEQ))
	}
	if l.UserEmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*l.UserEmailNEQ))
	}
	if l.UserEmailIn != nil {
		predicates = append(predicates, user.EmailIn(l.UserEmailIn...))
	}
	if l.UserEmailNotIn != nil {
		predicates = append(predicates, user.EmailNotIn(l.UserEmailNotIn...))
	}
	if l.UserEmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*l.UserEmailEqualFold))
	}
	if l.UserEmailContains != nil {
		predicates = append(predicates, user.EmailContains(*l.UserEmailContains))
	}
	if l.UserEmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*l.UserEmailContainsFold))
	}
	if l.UserEmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*l.UserEmailHasPrefix))
	}
	if l.UserEmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*l.UserEmailHasSuffix))
	}

	return l.ApplyFilterOperation(predicates...)
}

// ApplySorting applies sorting to the query based on the provided sort and order fields.
func (l *ListUserParams) ApplySorting(query *ent.UserQuery) error {
	if err := l.Sorted.Validate(UserSortConfig); err != nil {
		return err
	}
	if l.Field == nil { // No custom sort field provided and no defaults, so don't do anything.
		return nil
	}
	applySortingUser(query, *l.Field, *l.Order)
	return nil
}

// Exec wraps all logic (filtering, sorting, pagination, eager loading) and
// executes all necessary queries, returning the results.
func (l *ListUserParams) Exec(ctx context.Context, query *ent.UserQuery) (results *PagedResponse[ent.User], err error) {
	predicates, err := l.FilterPredicates()
	if err != nil {
		return nil, err
	}
	query.Where(predicates)
	err = l.ApplySorting(EagerLoadUser(query))
	if err != nil {
		return nil, err
	}
	return l.ExecutePaginated(ctx, query, UserPageConfig)
}
