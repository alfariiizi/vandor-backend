// Code generated by ent, DO NOT EDIT.

package rest

import (
	"context"
	"time"

	ent "github.com/alfariiizi/vandor/internal/infrastructure/db"
	"github.com/alfariiizi/vandor/internal/infrastructure/db/notification"
	"github.com/alfariiizi/vandor/internal/infrastructure/db/product"
	"github.com/alfariiizi/vandor/internal/infrastructure/db/session"
	"github.com/alfariiizi/vandor/internal/infrastructure/db/user"

	uuid "github.com/google/uuid"
)

// UpdateNotificationParams defines parameters for updating a Notification via a PATCH request.
type UpdateNotificationParams struct {
	// Last update time (UTC)
	UpdatedAt    Option[time.Time]              `json:"updated_at"`
	UserID       Option[uuid.UUID]              `json:"user_id"`
	Title        Option[string]                 `json:"title"`
	Message      Option[string]                 `json:"message"`
	Type         Option[notification.Type]      `json:"type"`
	Priority     Option[notification.Priority]  `json:"priority"`
	Channel      Option[notification.Channel]   `json:"channel"`
	Read         Option[bool]                   `json:"read"`
	Archived     Option[bool]                   `json:"archived"`
	Sticky       Option[bool]                   `json:"sticky"`
	Link         Option[*string]                `json:"link,omitempty"`
	Action       Option[*string]                `json:"action,omitempty"`
	ResourceType Option[*string]                `json:"resource_type,omitempty"`
	ResourceID   Option[*string]                `json:"resource_id,omitempty"`
	GroupKey     Option[*string]                `json:"group_key,omitempty"`
	DedupeKey    Option[*string]                `json:"dedupe_key,omitempty"`
	DeliveredAt  Option[*time.Time]             `json:"delivered_at,omitempty"`
	ReadAt       Option[*time.Time]             `json:"read_at,omitempty"`
	ExpiresAt    Option[*time.Time]             `json:"expires_at,omitempty"`
	Meta         Option[map[string]interface{}] `json:"meta,omitempty"`
}

func (u *UpdateNotificationParams) ApplyInputs(builder *ent.NotificationUpdateOne) *ent.NotificationUpdateOne {
	if v, ok := u.UpdatedAt.Get(); ok {
		builder.SetUpdatedAt(v)
	}
	if v, ok := u.UserID.Get(); ok {
		builder.SetUserID(v)
	}
	if v, ok := u.Title.Get(); ok {
		builder.SetTitle(v)
	}
	if v, ok := u.Message.Get(); ok {
		builder.SetMessage(v)
	}
	if v, ok := u.Type.Get(); ok {
		builder.SetType(v)
	}
	if v, ok := u.Priority.Get(); ok {
		builder.SetPriority(v)
	}
	if v, ok := u.Channel.Get(); ok {
		builder.SetChannel(v)
	}
	if v, ok := u.Read.Get(); ok {
		builder.SetRead(v)
	}
	if v, ok := u.Archived.Get(); ok {
		builder.SetArchived(v)
	}
	if v, ok := u.Sticky.Get(); ok {
		builder.SetSticky(v)
	}
	if v, ok := u.Link.Get(); ok {
		if v != nil {
			builder.SetLink(*v)
		} else {
			builder.ClearLink()
		}
	}
	if v, ok := u.Action.Get(); ok {
		if v != nil {
			builder.SetAction(*v)
		} else {
			builder.ClearAction()
		}
	}
	if v, ok := u.ResourceType.Get(); ok {
		if v != nil {
			builder.SetResourceType(*v)
		} else {
			builder.ClearResourceType()
		}
	}
	if v, ok := u.ResourceID.Get(); ok {
		if v != nil {
			builder.SetResourceID(*v)
		} else {
			builder.ClearResourceID()
		}
	}
	if v, ok := u.GroupKey.Get(); ok {
		if v != nil {
			builder.SetGroupKey(*v)
		} else {
			builder.ClearGroupKey()
		}
	}
	if v, ok := u.DedupeKey.Get(); ok {
		if v != nil {
			builder.SetDedupeKey(*v)
		} else {
			builder.ClearDedupeKey()
		}
	}
	if v, ok := u.DeliveredAt.Get(); ok {
		if v != nil {
			builder.SetDeliveredAt(*v)
		} else {
			builder.ClearDeliveredAt()
		}
	}
	if v, ok := u.ReadAt.Get(); ok {
		if v != nil {
			builder.SetReadAt(*v)
		} else {
			builder.ClearReadAt()
		}
	}
	if v, ok := u.ExpiresAt.Get(); ok {
		if v != nil {
			builder.SetExpiresAt(*v)
		} else {
			builder.ClearExpiresAt()
		}
	}
	if v, ok := u.Meta.Get(); ok {
		builder.SetMeta(v)
	}

	return builder
}

// Exec wraps all logic (mapping all provided values to the build), updates the entity,
// and does another query (using provided query as base) to get the entity, with all eager
// loaded edges.
func (c *UpdateNotificationParams) Exec(ctx context.Context, builder *ent.NotificationUpdateOne, query *ent.NotificationQuery) (*ent.Notification, error) {
	result, err := c.ApplyInputs(builder).Save(ctx)
	if err != nil {
		return nil, err
	}
	return EagerLoadNotification(query.Where(notification.ID(result.ID))).Only(ctx)
}

// UpdateProductParams defines parameters for updating a Product via a PATCH request.
type UpdateProductParams struct {
	UpdateTime Option[time.Time] `json:"update_time"`
	// nama_produk / product title
	Title            Option[string] `json:"title,omitempty"`
	ShortDescription Option[string] `json:"short_description,omitempty"`
	LongDescription  Option[string] `json:"long_description,omitempty"`
	// price in smallest currency unit (IDR -> 107000)
	Price    Option[int64]  `json:"price,omitempty"`
	Currency Option[string] `json:"currency,omitempty"`
	Stock    Option[int]    `json:"stock,omitempty"`
	// weight in grams, convert if source uses different unit
	WeightGrams     Option[int]       `json:"weight_grams,omitempty"`
	PackageLengthMm Option[int]       `json:"package_length_mm,omitempty"`
	PackageWidthMm  Option[int]       `json:"package_width_mm,omitempty"`
	PackageHeightMm Option[int]       `json:"package_height_mm,omitempty"`
	UserID          Option[uuid.UUID] `json:"user_id"`
}

func (u *UpdateProductParams) ApplyInputs(builder *ent.ProductUpdateOne) *ent.ProductUpdateOne {
	if v, ok := u.UpdateTime.Get(); ok {
		builder.SetUpdateTime(v)
	}
	if v, ok := u.Title.Get(); ok {
		builder.SetTitle(v)
	}
	if v, ok := u.ShortDescription.Get(); ok {
		builder.SetShortDescription(v)
	}
	if v, ok := u.LongDescription.Get(); ok {
		builder.SetLongDescription(v)
	}
	if v, ok := u.Price.Get(); ok {
		builder.SetPrice(v)
	}
	if v, ok := u.Currency.Get(); ok {
		builder.SetCurrency(v)
	}
	if v, ok := u.Stock.Get(); ok {
		builder.SetStock(v)
	}
	if v, ok := u.WeightGrams.Get(); ok {
		builder.SetWeightGrams(v)
	}
	if v, ok := u.PackageLengthMm.Get(); ok {
		builder.SetPackageLengthMm(v)
	}
	if v, ok := u.PackageWidthMm.Get(); ok {
		builder.SetPackageWidthMm(v)
	}
	if v, ok := u.PackageHeightMm.Get(); ok {
		builder.SetPackageHeightMm(v)
	}
	if v, ok := u.UserID.Get(); ok {
		builder.SetUserID(v)
	}

	return builder
}

// Exec wraps all logic (mapping all provided values to the build), updates the entity,
// and does another query (using provided query as base) to get the entity, with all eager
// loaded edges.
func (c *UpdateProductParams) Exec(ctx context.Context, builder *ent.ProductUpdateOne, query *ent.ProductQuery) (*ent.Product, error) {
	result, err := c.ApplyInputs(builder).Save(ctx)
	if err != nil {
		return nil, err
	}
	return EagerLoadProduct(query.Where(product.ID(result.ID))).Only(ctx)
}

// UpdateSessionParams defines parameters for updating a Session via a PATCH request.
type UpdateSessionParams struct {
	IPAddress    Option[string]     `json:"ip_address,omitempty"`
	UserAgent    Option[string]     `json:"user_agent,omitempty"`
	DeviceID     Option[string]     `json:"device_id,omitempty"`
	NumberOfUses Option[uint64]     `json:"number_of_uses"`
	LastUsedAt   Option[time.Time]  `json:"last_used_at"`
	CreatedAt    Option[time.Time]  `json:"created_at"`
	RevokedAt    Option[*time.Time] `json:"revoked_at,omitempty"`
	UserID       Option[uuid.UUID]  `json:"user_id"`
}

func (u *UpdateSessionParams) ApplyInputs(builder *ent.SessionUpdateOne) *ent.SessionUpdateOne {
	if v, ok := u.IPAddress.Get(); ok {
		builder.SetIPAddress(v)
	}
	if v, ok := u.UserAgent.Get(); ok {
		builder.SetUserAgent(v)
	}
	if v, ok := u.DeviceID.Get(); ok {
		builder.SetDeviceID(v)
	}
	if v, ok := u.NumberOfUses.Get(); ok {
		builder.SetNumberOfUses(v)
	}
	if v, ok := u.LastUsedAt.Get(); ok {
		builder.SetLastUsedAt(v)
	}
	if v, ok := u.CreatedAt.Get(); ok {
		builder.SetCreatedAt(v)
	}
	if v, ok := u.RevokedAt.Get(); ok {
		if v != nil {
			builder.SetRevokedAt(*v)
		} else {
			builder.ClearRevokedAt()
		}
	}
	if v, ok := u.UserID.Get(); ok {
		builder.SetUserID(v)
	}

	return builder
}

// Exec wraps all logic (mapping all provided values to the build), updates the entity,
// and does another query (using provided query as base) to get the entity, with all eager
// loaded edges.
func (c *UpdateSessionParams) Exec(ctx context.Context, builder *ent.SessionUpdateOne, query *ent.SessionQuery) (*ent.Session, error) {
	result, err := c.ApplyInputs(builder).Save(ctx)
	if err != nil {
		return nil, err
	}
	return EagerLoadSession(query.Where(session.ID(result.ID))).Only(ctx)
}

// UpdateUserParams defines parameters for updating a User via a PATCH request.
type UpdateUserParams struct {
	Email               Option[string]      `json:"email"`
	FirstName           Option[string]      `json:"first_name"`
	LastName            Option[string]      `json:"last_name"`
	PasswordHash        Option[string]      `json:"password_hash"`
	Role                Option[user.Role]   `json:"role"`
	UpdatedAt           Option[time.Time]   `json:"updated_at"`
	AddProducts         Option[[]uuid.UUID] `json:"add_products,omitempty"`
	RemoveProducts      Option[[]uuid.UUID] `json:"remove_products,omitempty"`
	AddSessions         Option[[]uuid.UUID] `json:"add_sessions,omitempty"`
	RemoveSessions      Option[[]uuid.UUID] `json:"remove_sessions,omitempty"`
	AddNotifications    Option[[]uuid.UUID] `json:"add_notifications,omitempty"`
	RemoveNotifications Option[[]uuid.UUID] `json:"remove_notifications,omitempty"`
}

func (u *UpdateUserParams) ApplyInputs(builder *ent.UserUpdateOne) *ent.UserUpdateOne {
	if v, ok := u.Email.Get(); ok {
		builder.SetEmail(v)
	}
	if v, ok := u.FirstName.Get(); ok {
		builder.SetFirstName(v)
	}
	if v, ok := u.LastName.Get(); ok {
		builder.SetLastName(v)
	}
	if v, ok := u.PasswordHash.Get(); ok {
		builder.SetPasswordHash(v)
	}
	if v, ok := u.Role.Get(); ok {
		builder.SetRole(v)
	}
	if v, ok := u.UpdatedAt.Get(); ok {
		builder.SetUpdatedAt(v)
	}

	if v, ok := u.AddProducts.Get(); ok && v != nil {
		builder.AddProductIDs(v...)
	}
	if v, ok := u.RemoveProducts.Get(); ok && v != nil {
		builder.RemoveProductIDs(v...)
	}
	if v, ok := u.AddSessions.Get(); ok && v != nil {
		builder.AddSessionIDs(v...)
	}
	if v, ok := u.RemoveSessions.Get(); ok && v != nil {
		builder.RemoveSessionIDs(v...)
	}
	if v, ok := u.AddNotifications.Get(); ok && v != nil {
		builder.AddNotificationIDs(v...)
	}
	if v, ok := u.RemoveNotifications.Get(); ok && v != nil {
		builder.RemoveNotificationIDs(v...)
	}
	return builder
}

// Exec wraps all logic (mapping all provided values to the build), updates the entity,
// and does another query (using provided query as base) to get the entity, with all eager
// loaded edges.
func (c *UpdateUserParams) Exec(ctx context.Context, builder *ent.UserUpdateOne, query *ent.UserQuery) (*ent.User, error) {
	result, err := c.ApplyInputs(builder).Save(ctx)
	if err != nil {
		return nil, err
	}
	return EagerLoadUser(query.Where(user.ID(result.ID))).Only(ctx)
}
