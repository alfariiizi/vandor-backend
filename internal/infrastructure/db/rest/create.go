// Code generated by ent, DO NOT EDIT.

package rest

import (
	"context"
	"time"

	ent "github.com/alfariiizi/vandor/internal/infrastructure/db"
	"github.com/alfariiizi/vandor/internal/infrastructure/db/notification"
	"github.com/alfariiizi/vandor/internal/infrastructure/db/product"
	"github.com/alfariiizi/vandor/internal/infrastructure/db/session"
	"github.com/alfariiizi/vandor/internal/infrastructure/db/user"

	uuid "github.com/google/uuid"
)

// CreateNotificationParams defines parameters for creating a Notification via a POST request.
type CreateNotificationParams struct {
	// Creation time (UTC)
	CreatedAt *time.Time `json:"created_at"`
	// Last update time (UTC)
	UpdatedAt    *time.Time              `json:"updated_at"`
	UserID       uuid.UUID               `json:"user_id"`
	Title        string                  `json:"title"`
	Message      string                  `json:"message"`
	Type         *notification.Type      `json:"type"`
	Priority     *notification.Priority  `json:"priority"`
	Channel      *notification.Channel   `json:"channel"`
	Read         *bool                   `json:"read"`
	Archived     *bool                   `json:"archived"`
	Sticky       *bool                   `json:"sticky"`
	Link         *string                 `json:"link,omitempty"`
	Action       *string                 `json:"action,omitempty"`
	ResourceType *string                 `json:"resource_type,omitempty"`
	ResourceID   *string                 `json:"resource_id,omitempty"`
	GroupKey     *string                 `json:"group_key,omitempty"`
	DedupeKey    *string                 `json:"dedupe_key,omitempty"`
	DeliveredAt  *time.Time              `json:"delivered_at,omitempty"`
	ReadAt       *time.Time              `json:"read_at,omitempty"`
	ExpiresAt    *time.Time              `json:"expires_at,omitempty"`
	Meta         *map[string]interface{} `json:"meta,omitempty"`
}

func (c *CreateNotificationParams) ApplyInputs(builder *ent.NotificationCreate) *ent.NotificationCreate {
	if c.CreatedAt != nil {
		builder.SetCreatedAt(*c.CreatedAt)
	}
	if c.UpdatedAt != nil {
		builder.SetUpdatedAt(*c.UpdatedAt)
	}
	builder.SetUserID(c.UserID)
	builder.SetTitle(c.Title)
	builder.SetMessage(c.Message)
	if c.Type != nil {
		builder.SetType(*c.Type)
	}
	if c.Priority != nil {
		builder.SetPriority(*c.Priority)
	}
	if c.Channel != nil {
		builder.SetChannel(*c.Channel)
	}
	if c.Read != nil {
		builder.SetRead(*c.Read)
	}
	if c.Archived != nil {
		builder.SetArchived(*c.Archived)
	}
	if c.Sticky != nil {
		builder.SetSticky(*c.Sticky)
	}
	if c.Link != nil {
		builder.SetLink(*c.Link)
	}
	if c.Action != nil {
		builder.SetAction(*c.Action)
	}
	if c.ResourceType != nil {
		builder.SetResourceType(*c.ResourceType)
	}
	if c.ResourceID != nil {
		builder.SetResourceID(*c.ResourceID)
	}
	if c.GroupKey != nil {
		builder.SetGroupKey(*c.GroupKey)
	}
	if c.DedupeKey != nil {
		builder.SetDedupeKey(*c.DedupeKey)
	}
	if c.DeliveredAt != nil {
		builder.SetDeliveredAt(*c.DeliveredAt)
	}
	if c.ReadAt != nil {
		builder.SetReadAt(*c.ReadAt)
	}
	if c.ExpiresAt != nil {
		builder.SetExpiresAt(*c.ExpiresAt)
	}
	if c.Meta != nil {
		builder.SetMeta(*c.Meta)
	}
	return builder
}

// Exec wraps all logic (mapping all provided values to the builder), creates the entity,
// and does another query (using provided query as base) to get the entity, with all eager
// loaded edges.
func (c *CreateNotificationParams) Exec(ctx context.Context, builder *ent.NotificationCreate, query *ent.NotificationQuery) (*ent.Notification, error) {
	result, err := c.ApplyInputs(builder).Save(ctx)
	if err != nil {
		return nil, err
	}
	return EagerLoadNotification(query.Where(notification.ID(result.ID))).Only(ctx)
}

// CreateProductParams defines parameters for creating a Product via a POST request.
type CreateProductParams struct {
	CreateTime *time.Time `json:"create_time"`
	UpdateTime *time.Time `json:"update_time"`
	// nama_produk / product title
	Title            *string `json:"title,omitempty"`
	ShortDescription *string `json:"short_description,omitempty"`
	LongDescription  *string `json:"long_description,omitempty"`
	// price in smallest currency unit (IDR -> 107000)
	Price    *int64  `json:"price,omitempty"`
	Currency *string `json:"currency,omitempty"`
	Stock    *int    `json:"stock,omitempty"`
	// weight in grams, convert if source uses different unit
	WeightGrams     *int      `json:"weight_grams,omitempty"`
	PackageLengthMm *int      `json:"package_length_mm,omitempty"`
	PackageWidthMm  *int      `json:"package_width_mm,omitempty"`
	PackageHeightMm *int      `json:"package_height_mm,omitempty"`
	UserID          uuid.UUID `json:"user_id"`
}

func (c *CreateProductParams) ApplyInputs(builder *ent.ProductCreate) *ent.ProductCreate {
	if c.CreateTime != nil {
		builder.SetCreateTime(*c.CreateTime)
	}
	if c.UpdateTime != nil {
		builder.SetUpdateTime(*c.UpdateTime)
	}
	if c.Title != nil {
		builder.SetTitle(*c.Title)
	}
	if c.ShortDescription != nil {
		builder.SetShortDescription(*c.ShortDescription)
	}
	if c.LongDescription != nil {
		builder.SetLongDescription(*c.LongDescription)
	}
	if c.Price != nil {
		builder.SetPrice(*c.Price)
	}
	if c.Currency != nil {
		builder.SetCurrency(*c.Currency)
	}
	if c.Stock != nil {
		builder.SetStock(*c.Stock)
	}
	if c.WeightGrams != nil {
		builder.SetWeightGrams(*c.WeightGrams)
	}
	if c.PackageLengthMm != nil {
		builder.SetPackageLengthMm(*c.PackageLengthMm)
	}
	if c.PackageWidthMm != nil {
		builder.SetPackageWidthMm(*c.PackageWidthMm)
	}
	if c.PackageHeightMm != nil {
		builder.SetPackageHeightMm(*c.PackageHeightMm)
	}
	builder.SetUserID(c.UserID)
	return builder
}

// Exec wraps all logic (mapping all provided values to the builder), creates the entity,
// and does another query (using provided query as base) to get the entity, with all eager
// loaded edges.
func (c *CreateProductParams) Exec(ctx context.Context, builder *ent.ProductCreate, query *ent.ProductQuery) (*ent.Product, error) {
	result, err := c.ApplyInputs(builder).Save(ctx)
	if err != nil {
		return nil, err
	}
	return EagerLoadProduct(query.Where(product.ID(result.ID))).Only(ctx)
}

// CreateSessionParams defines parameters for creating a Session via a POST request.
type CreateSessionParams struct {
	RefreshToken string     `json:"refresh_token"`
	IPAddress    *string    `json:"ip_address,omitempty"`
	UserAgent    *string    `json:"user_agent,omitempty"`
	DeviceID     *string    `json:"device_id,omitempty"`
	NumberOfUses *uint64    `json:"number_of_uses"`
	ExpiresAt    *time.Time `json:"expires_at"`
	LastUsedAt   *time.Time `json:"last_used_at"`
	CreatedAt    *time.Time `json:"created_at"`
	RevokedAt    *time.Time `json:"revoked_at,omitempty"`
	UserID       uuid.UUID  `json:"user_id"`
}

func (c *CreateSessionParams) ApplyInputs(builder *ent.SessionCreate) *ent.SessionCreate {
	builder.SetRefreshToken(c.RefreshToken)
	if c.IPAddress != nil {
		builder.SetIPAddress(*c.IPAddress)
	}
	if c.UserAgent != nil {
		builder.SetUserAgent(*c.UserAgent)
	}
	if c.DeviceID != nil {
		builder.SetDeviceID(*c.DeviceID)
	}
	if c.NumberOfUses != nil {
		builder.SetNumberOfUses(*c.NumberOfUses)
	}
	if c.ExpiresAt != nil {
		builder.SetExpiresAt(*c.ExpiresAt)
	}
	if c.LastUsedAt != nil {
		builder.SetLastUsedAt(*c.LastUsedAt)
	}
	if c.CreatedAt != nil {
		builder.SetCreatedAt(*c.CreatedAt)
	}
	if c.RevokedAt != nil {
		builder.SetRevokedAt(*c.RevokedAt)
	}
	builder.SetUserID(c.UserID)
	return builder
}

// Exec wraps all logic (mapping all provided values to the builder), creates the entity,
// and does another query (using provided query as base) to get the entity, with all eager
// loaded edges.
func (c *CreateSessionParams) Exec(ctx context.Context, builder *ent.SessionCreate, query *ent.SessionQuery) (*ent.Session, error) {
	result, err := c.ApplyInputs(builder).Save(ctx)
	if err != nil {
		return nil, err
	}
	return EagerLoadSession(query.Where(session.ID(result.ID))).Only(ctx)
}

// CreateUserParams defines parameters for creating a User via a POST request.
type CreateUserParams struct {
	Email         string      `json:"email"`
	FirstName     string      `json:"first_name"`
	LastName      string      `json:"last_name"`
	PasswordHash  string      `json:"password_hash"`
	Role          user.Role   `json:"role"`
	CreatedAt     *time.Time  `json:"created_at"`
	UpdatedAt     *time.Time  `json:"updated_at"`
	Products      []uuid.UUID `json:"products,omitempty"`
	Sessions      []uuid.UUID `json:"sessions,omitempty"`
	Notifications []uuid.UUID `json:"notifications,omitempty"`
}

func (c *CreateUserParams) ApplyInputs(builder *ent.UserCreate) *ent.UserCreate {
	builder.SetEmail(c.Email)
	builder.SetFirstName(c.FirstName)
	builder.SetLastName(c.LastName)
	builder.SetPasswordHash(c.PasswordHash)
	builder.SetRole(c.Role)
	if c.CreatedAt != nil {
		builder.SetCreatedAt(*c.CreatedAt)
	}
	if c.UpdatedAt != nil {
		builder.SetUpdatedAt(*c.UpdatedAt)
	}
	builder.AddProductIDs(c.Products...)
	builder.AddSessionIDs(c.Sessions...)
	builder.AddNotificationIDs(c.Notifications...)
	return builder
}

// Exec wraps all logic (mapping all provided values to the builder), creates the entity,
// and does another query (using provided query as base) to get the entity, with all eager
// loaded edges.
func (c *CreateUserParams) Exec(ctx context.Context, builder *ent.UserCreate, query *ent.UserQuery) (*ent.User, error) {
	result, err := c.ApplyInputs(builder).Save(ctx)
	if err != nil {
		return nil, err
	}
	return EagerLoadUser(query.Where(user.ID(result.ID))).Only(ctx)
}
