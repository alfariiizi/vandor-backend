package main

import (
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"gopkg.in/yaml.v3"
)

// EnumDefinition represents the structure of a YAML enum definition
type EnumDefinition struct {
	Type        string            `yaml:"type"`
	Values      map[string]string `yaml:"values"`
	Description string            `yaml:"description,omitempty"`
}

// EnumValue represents a single enum value with its metadata
type EnumValue struct {
	Name        string // Original key from YAML (e.g., "PENDING")
	ConstName   string // Go constant name (e.g., "OrderStatusPending")
	FieldName   string // Struct field name (e.g., "Pending")
	Description string // Human readable description
}

// TemplateData holds all data needed for template generation
type TemplateData struct {
	Type        string
	Package     string
	Values      []EnumValue
	Description string
}

const enumTemplate = `// Code generated by Vandor. DO NOT EDIT.

package enum

import (
	"encoding/json"
	"fmt"
	"strings"
)

{{if .Description}}// {{.Description}}{{end}}
type {{.Type}} string

const (
{{- range .Values}}
	// {{.Description}}
	{{.ConstName}} {{$.Type}} = "{{.Name}}"
{{- end}}
)

var All{{.Type}}s = []{{.Type}}{
{{- range .Values}}
	{{.ConstName}},
{{- end}}
}

var {{.Type}}Enum = struct {
{{- range .Values}}
	{{.FieldName}}    {{$.Type}}
{{- end}}
}{
{{- range .Values}}
	{{.FieldName}}:    {{.ConstName}},
{{- end}}
}

var {{lcFirst .Type}}Labels = map[{{.Type}}]string{
{{- range .Values}}
	{{.ConstName}}:    "{{.Description}}",
{{- end}}
}

func (e {{.Type}}) IsValid() bool {
	switch e {
	case {{range $i, $v := .Values}}{{if $i}},
		{{end}}{{$v.ConstName}}{{end}}:
		return true
	}
	return false
}

func (e {{.Type}}) String() string {
	return string(e)
}

func (e {{.Type}}) Label() string {
	if label, ok := {{lcFirst .Type}}Labels[e]; ok {
		return label
	}
	return string(e)
}

func Parse{{.Type}}(s string) ({{.Type}}, error) {
	switch strings.ToUpper(s) {
{{- range .Values}}
	case "{{.Name}}":
		return {{.ConstName}}, nil
{{- end}}
	}
	return "", fmt.Errorf("invalid {{.Type}}: %s", s)
}

func (e {{.Type}}) MarshalJSON() ([]byte, error) {
	return json.Marshal(string(e))
}

func (e *{{.Type}}) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	val, err := Parse{{.Type}}(s)
	if err != nil {
		return err
	}
	*e = val
	return nil
}
`

func main() {
	if len(os.Args) < 2 {
		fmt.Println("Usage:")
		fmt.Println("  enum-generator add <enum-name>    - Create a new YAML enum file")
		fmt.Println("  enum-generator generate           - Generate Go enums from all YAML files")
		os.Exit(1)
	}

	command := os.Args[1]
	switch command {
	case "add":
		if len(os.Args) < 3 {
			fmt.Println("Usage: enum-generator add <enum-name>")
			os.Exit(1)
		}
		addEnum(os.Args[2])
	case "generate":
		generateEnums()
	default:
		fmt.Printf("Unknown command: %s\n", command)
		os.Exit(1)
	}
}

func addEnum(enumName string) {
	// Ensure enum directory exists
	if err := os.MkdirAll("enum", 0755); err != nil {
		fmt.Printf("Error creating enum directory: %v\n", err)
		os.Exit(1)
	}

	// Convert enum name to proper format
	typeName := toPascalCase(enumName)
	fileName := fmt.Sprintf("enum/%s.yaml", toSnakeCase(enumName))

	// Check if file already exists
	if _, err := os.Stat(fileName); err == nil {
		fmt.Printf("Enum file %s already exists\n", fileName)
		return
	}

	// Create template YAML content
	template := fmt.Sprintf(`type: %s
description: Description for %s enum
values:
  EXAMPLE_VALUE_1: Description for example value 1
  EXAMPLE_VALUE_2: Description for example value 2
`, typeName, typeName)

	// Write file
	if err := os.WriteFile(fileName, []byte(template), 0644); err != nil {
		fmt.Printf("Error creating enum file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Created enum file: %s\n", fileName)
	fmt.Println("Please edit the file and add your enum values, then run 'enum-generator generate'")
}

func generateEnums() {
	// Ensure output directory exists
	if err := os.MkdirAll("internal/enum", 0755); err != nil {
		fmt.Printf("Error creating output directory: %v\n", err)
		os.Exit(1)
	}

	// Find all YAML files in enum directory
	yamlFiles, err := findYAMLFiles("enum")
	if err != nil {
		fmt.Printf("Error finding YAML files: %v\n", err)
		os.Exit(1)
	}

	if len(yamlFiles) == 0 {
		fmt.Println("No YAML files found in enum directory")
		return
	}

	// Parse template
	tmpl, err := template.New("enum").Funcs(template.FuncMap{
		"lcFirst": lcFirst,
	}).Parse(enumTemplate)
	if err != nil {
		fmt.Printf("Error parsing template: %v\n", err)
		os.Exit(1)
	}

	// Process each YAML file
	for _, yamlFile := range yamlFiles {
		fmt.Printf("Processing %s...\n", yamlFile)

		if err := processEnumFile(yamlFile, tmpl); err != nil {
			fmt.Printf("Error processing %s: %v\n", yamlFile, err)
			continue
		}
	}

	fmt.Printf("Successfully generated %d enum files\n", len(yamlFiles))
}

func findYAMLFiles(dir string) ([]string, error) {
	var yamlFiles []string

	err := filepath.WalkDir(dir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		if !d.IsDir() && (strings.HasSuffix(path, ".yaml") || strings.HasSuffix(path, ".yml")) {
			yamlFiles = append(yamlFiles, path)
		}
		return nil
	})

	return yamlFiles, err
}

func processEnumFile(yamlFile string, tmpl *template.Template) error {
	// Read YAML file
	data, err := os.ReadFile(yamlFile)
	if err != nil {
		return fmt.Errorf("reading file: %w", err)
	}

	// Parse YAML
	var enumDef EnumDefinition
	if err := yaml.Unmarshal(data, &enumDef); err != nil {
		return fmt.Errorf("parsing YAML: %w", err)
	}

	// Validate required fields
	if enumDef.Type == "" {
		return fmt.Errorf("missing required field 'type'")
	}
	if len(enumDef.Values) == 0 {
		return fmt.Errorf("missing required field 'values' or values is empty")
	}

	// Prepare template data
	templateData := TemplateData{
		Type:        enumDef.Type,
		Package:     "enum",
		Description: enumDef.Description,
	}

	// Process values
	var keys []string
	for key := range enumDef.Values {
		keys = append(keys, key)
	}
	sort.Strings(keys) // Ensure consistent ordering

	for _, key := range keys {
		description := enumDef.Values[key]
		if description == "" {
			description = key // Fallback to key if no description
		}

		templateData.Values = append(templateData.Values, EnumValue{
			Name:        key,
			ConstName:   fmt.Sprintf("%s%s", enumDef.Type, toPascalCase(key)),
			FieldName:   toPascalCase(key),
			Description: description,
		})
	}

	// Generate output file
	outputFile := fmt.Sprintf("internal/enum/%s.go", toSnakeCase(enumDef.Type))
	file, err := os.Create(outputFile)
	if err != nil {
		return fmt.Errorf("creating output file: %w", err)
	}
	defer file.Close()

	// Execute template
	if err := tmpl.Execute(file, templateData); err != nil {
		return fmt.Errorf("executing template: %w", err)
	}

	fmt.Printf("Generated: %s\n", outputFile)
	return nil
}

// Utility functions for string conversion
func toPascalCase(s string) string {
	words := strings.FieldsFunc(s, func(c rune) bool {
		return c == '_' || c == '-' || c == ' '
	})

	for i, word := range words {
		words[i] = strings.Title(strings.ToLower(word))
	}

	return strings.Join(words, "")
}

func toSnakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result.WriteRune('_')
		}
		result.WriteRune(r)
	}
	return strings.ToLower(result.String())
}

func lcFirst(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToLower(s[:1]) + s[1:]
}
