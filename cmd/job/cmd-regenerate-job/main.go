package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/alfariiizi/vandor/cmd/utils"
)

type JobInfo struct {
	ModuleName string // Module name e.g. vandor
	BaseName   string // SendEmail
	Name       string // Struct name e.g. SendEmail
	VarName    string // var name e.g. sendEmail
	TaskName   string // e.g. send_email
	Payload    string // Payload struct name
}

func main() {
	// if len(os.Args) < 3 {
	// 	fmt.Println("Invalid arguments")
	// 	return
	// }

	jobsDir := "internal/core/job"
	var jobs []JobInfo

	filepath.Walk(jobsDir, func(path string, info os.FileInfo, err error) error {
		if strings.HasSuffix(path, "_job.go") {
			job := parseJob(path)
			if job.Name != "" {
				jobs = append(jobs, job)
			}
		}
		return nil
	})

	generateJobsGo(jobs)
	generateWorkerGen(jobs)

	fmt.Println("Generated jobs.go and worker_gen.go")
}

func parseJob(path string) JobInfo {
	fset := token.NewFileSet()
	node, _ := parser.ParseFile(fset, path, nil, parser.AllErrors)
	job := JobInfo{}
	for _, decl := range node.Decls {
		if g, ok := decl.(*ast.GenDecl); ok && g.Tok == token.TYPE {
			for _, spec := range g.Specs {
				ts := spec.(*ast.TypeSpec)
				if !strings.HasPrefix(ts.Name.Name, "New") {
					// base := ts.Name.Name
					// name := strings.TrimSuffix(strings.Title(base), "Job")
					// job.ModuleName = utils.GetModuleName()
					// job.Name = name
					// job.VarName = name
					// job.TaskName = toTaskName(strings.ToLower(name[0:1]) + name[1:])
					// job.Payload = name + "Payload"
					base := strings.TrimSuffix(ts.Name.Name, "Job")
					// if !strings.HasSuffix(ts.Name.Name, "Job") {
					// 	continue
					// }
					// job.ModuleName = utils.GetModuleName()
					job.BaseName = strings.ToUpper(base[:1]) + base[1:]
					job.Name = job.BaseName
					job.VarName = strings.ToLower(base[:1]) + base[1:]
					job.TaskName = toTaskName(job.VarName)
					job.Payload = job.BaseName + "Payload"
					job.ModuleName = utils.GetModuleName()
				}
			}
		}
	}
	return job
}

func generateJobsGo(jobs []JobInfo) {
	tmpl := `// Code generated by vandor; DO NOT EDIT.
package job

import "go.uber.org/fx"

type Jobs struct {
{{- range . }}
    {{.BaseName}} {{.BaseName}}
{{- end }}
}

func NewJobs(
{{- range . }}
    {{.BaseName}} {{.BaseName}},
{{- end }}
) *Jobs {
    return &Jobs{
{{- range . }}
        {{.BaseName}}: {{.BaseName}},
{{- end }}
    }
}

var Module = fx.Module(
    "job",
    fx.Provide(
{{- range . }}
        New{{.BaseName}},
{{- end }}
        NewJobs,
    ),
    fx.Invoke(
	{{- range . }}
	func (j {{.BaseName}}) {
		j.HTTPRegisterRoute()
	},
	{{- end }}
    ),
)
`
	writeTemplate("internal/core/job/jobs.go", tmpl, jobs)
}

func generateWorkerGen(jobs []JobInfo) {
	tmplPath := "cmd/job/cmd-regenerate-job/templates/worker_gen.tmpl"
	tmplBytes, _ := os.ReadFile(tmplPath)
	writeTemplate("internal/infrastructure/asynq/worker_gen.go", string(tmplBytes), jobs)
}

func writeTemplate(path, tmpl string, data any) {
	t := template.Must(template.New("tmpl").Parse(tmpl))
	os.MkdirAll(filepath.Dir(path), os.ModePerm)
	f, _ := os.Create(path)
	defer f.Close()
	t.Execute(f, data)
}

func toTaskName(name string) string {
	var result []rune
	for i, r := range name {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result = append(result, '_', r+32)
		} else {
			result = append(result, r)
		}
	}
	return string(result)
}
