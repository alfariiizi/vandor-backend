package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/fs"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"

	"github.com/alfariiizi/vandor/cmd/utils"
)

func main() {
	schedulerDir := "internal/cron/scheduler"
	outputFile := filepath.Join(schedulerDir, "scheduler_registry.go") // moved to scheduler pkg

	var funcs []string
	funcPattern := regexp.MustCompile(`^Register.*Job$`)

	// Walk through scheduler folder
	_ = filepath.WalkDir(schedulerDir, func(path string, d fs.DirEntry, err error) error {
		if err != nil || d.IsDir() || !strings.HasSuffix(d.Name(), ".go") {
			return nil
		}

		fset := token.NewFileSet()
		node, err := parser.ParseFile(fset, path, nil, parser.AllErrors)
		if err != nil {
			fmt.Printf("Failed to parse %s: %v\n", path, err)
			return nil
		}

		// Traverse declarations
		for _, decl := range node.Decls {
			if fn, ok := decl.(*ast.FuncDecl); ok {
				if funcPattern.MatchString(fn.Name.Name) {
					funcs = append(funcs, fn.Name.Name)
				}
			}
		}
		return nil
	})

	// Sort functions for deterministic output
	sort.Strings(funcs)

	// Generate file content
	builder := &strings.Builder{}
	fmt.Fprintln(builder, "// Code generated by Vandor CLI; DO NOT EDIT.")
	fmt.Fprintln(builder, "package scheduler\n")
	importModule := fmt.Sprintf(`import cron "%s/internal/cron/init"`, utils.GetModuleName())
	fmt.Fprintln(builder, importModule)
	fmt.Fprintln(builder, "\nfunc RegisterJobs(s *cron.Scheduler) {")
	for _, fn := range funcs {
		fmt.Fprintf(builder, "\t%s(s)\n", fn)
	}
	fmt.Fprintln(builder, "}")

	// Ensure directory exists
	_ = os.MkdirAll(filepath.Dir(outputFile), os.ModePerm)

	// Write to file
	if err := os.WriteFile(outputFile, []byte(builder.String()), 0644); err != nil {
		panic(err)
	}

	fmt.Printf("[OK] Generated %s with %d jobs.\n", outputFile, len(funcs))
}
